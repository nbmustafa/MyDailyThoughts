Here's a Terraform configuration that uses a single `null_resource` to apply multiple YAML files from one or more directories, including recursive subdirectories:

```hcl
terraform {
  required_providers {
    null = {
      source = "hashicorp/null"
    }
  }
}

locals {
  # List of directories containing manifests
  manifest_dirs = ["dir1", "dir2"]  # Add your directories here
  
  # Generate combined hash of all YAML files
  all_files = flatten([for dir in local.manifest_dirs : fileset("${path.module}/${dir}", "**/*.{yaml,yml}")])
  combined_hash = sha256(join("", [for file in local.all_files : filebase64sha256("${path.module}/${file}")]))
}

resource "null_resource" "kubectl_apply" {
  triggers = {
    manifest_hash = local.combined_hash
    kubeconfig   = filebase64sha256("~/.kube/config")
    timestamp    = timestamp()  # Force run on every apply
  }

  # Apply all manifests
  provisioner "local-exec" {
    command = <<-EOT
      ${join("\n", [for dir in local.manifest_dirs : "kubectl apply -R -f ${path.module}/${dir}"])}
    EOT
    environment = {
      KUBECONFIG = "~/.kube/config"
    }
  }

  # Delete all resources on destroy
  provisioner "local-exec" {
    when    = destroy
    command = <<-EOT
      ${join("\n", [for dir in self.triggers.manifest_dirs : "kubectl delete -R -f ${path.module}/${dir}"])}
    EOT
    environment = {
      KUBECONFIG = "~/.kube/config"
    }
  }
}
```

### Key Features:

1. **Multi-Directory Support**
   - Add directories to `local.manifest_dirs` list
   - Handles both YAML and YML file extensions
   - Processes files recursively in subdirectories

2. **Automatic Change Detection**
   - Generates combined SHA256 hash of all files
   - Triggers apply when any file changes
   - Detects kubeconfig changes

3. **Lifecycle Management**
   - Applies all manifests on `terraform apply`
   - Deletes all resources on `terraform destroy`
   - Forces re-apply on every run (via timestamp trigger)

4. **Recursive Processing**
   - Uses `-R` flag to process directories recursively
   - Handles complex directory structures

### Setup Instructions:

1. Create directory structure:
   ```
   .
   ├── main.tf
   ├── dir1/
   │   ├── deployment.yaml
   │   └── services/
   │       └── service.yaml
   └── dir2/
       ├── configmap.yaml
       └── ingress.yaml
   ```

2. Initialize Terraform:
   ```bash
   terraform init
   ```

3. Apply configuration:
   ```bash
   terraform apply
   ```

### Customization Options:

**1. Add additional directories:**
```hcl
locals {
  manifest_dirs = ["k8s/core", "k8s/monitoring", "external-configs"]
}
```

**2. Exclude specific files/directories:**
```hcl
all_files = flatten([for dir in local.manifest_dirs : 
  setsubtract(
    fileset("${path.module}/${dir}", "**/*.{yaml,yml}"),
    fileset("${path.module}/${dir}", "**/excluded-*")
  )
])
```

**3. Add server-side apply:**
```hcl
provisioner "local-exec" {
  command = <<-EOT
    ${join("\n", [for dir in local.manifest_dirs : 
      "kubectl apply --server-side -R -f ${path.module}/${dir}"
    ])}
  EOT
}
```

**4. Handle multiple environments:**
```hcl
variable "environment" {
  default = "dev"
}

provisioner "local-exec" {
  command = <<-EOT
    ${join("\n", [for dir in local.manifest_dirs : 
      "kubectl apply -R -f ${path.module}/${dir} --namespace ${var.environment}"
    ])}
  EOT
}
```

### Important Notes:

1. **Kubectl Requirements:**
   - Must have `kubectl` installed and in PATH
   - Kubernetes context must be properly configured
   - Test access with `kubectl cluster-info`

2. **File Handling:**
   - Processes files in alphabetical order
   - No dependency handling between files (use Kustomize for complex dependencies)
   - Hidden files (starting with `.`) are ignored

3. **Deletion Behavior:**
   - Deletes resources in reverse directory order
   - Resources are deleted using the same files used for creation
   - Files must exist at destroy time for proper cleanup

For complex deployments, consider using the official Kubernetes provider with `kubectl_manifest` resources instead. This null resource approach is best for simple deployments or when you need to maintain existing YAML files without Terraform conversions.