```go
package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"os"
	"os/exec"
	"sort"
	"strings"

	"gopkg.in/yaml.v3"
)

type Resource map[string]interface{}

type DiffEntry struct {
	Path string
	Type string // "added", "removed", "changed", "type_changed"
	Old  interface{}
	New  interface{}
}

type Diff struct {
	Kind         string
	Namespace    string
	Name         string
	Status       string // "new", "modified"
	Ownership    string // "helm", "other" (only for modified)
	ConflictNote string // only if potential conflict
	Diff         []DiffEntry
}

func main() {
	release := flag.String("release", "my-release", "Helm release name (default: my-release)")
	namespace := flag.String("namespace", "", "Target namespace (default: none, fetches all for namespaced resources)")
	outputFormat := flag.String("output", "text", "Output format (text or json)")
	flag.Parse()

	if flag.NArg() < 1 {
		fmt.Fprintf(os.Stderr, "Usage: %s [flags] <chart-path>\n", os.Args[0])
		flag.PrintDefaults()
		os.Exit(1)
	}
	chart := flag.Arg(0)

	fmt.Fprintln(os.Stderr, "Fetching existing resources...")
	existing := fetchExistingResources(*namespace)

	fmt.Fprintln(os.Stderr, "Rendering Helm chart...")
	rendered := renderHelmChart(*release, chart, *namespace)

	fmt.Fprintln(os.Stderr, "Comparing resources...")
	diffs := compareResources(existing, rendered)

	if *outputFormat == "json" {
		enc := json.NewEncoder(os.Stdout)
		enc.SetIndent("", "  ")
		if err := enc.Encode(diffs); err != nil {
			fmt.Fprintf(os.Stderr, "Error encoding JSON: %v\n", err)
		}
	} else {
		for _, d := range diffs {
			nsStr := d.Namespace
			if nsStr == "" {
				nsStr = "cluster-wide"
			}
			fmt.Printf("\n🔍 %s/%s in namespace %s\n", d.Kind, d.Name, nsStr)
			fmt.Printf("Status: %s\n", d.Status)
			if d.Ownership != "" {
				fmt.Printf("Ownership: %s\n", d.Ownership)
			}
			if d.ConflictNote != "" {
				fmt.Printf("⚠️ %s\n", d.ConflictNote)
			}
			if len(d.Diff) > 0 {
				fmt.Println("Differences:")
				for _, de := range d.Diff {
					oldStr := fmt.Sprintf("%v", de.Old)
					if de.Old == nil {
						oldStr = "null"
					}
					newStr := fmt.Sprintf("%v", de.New)
					if de.New == nil {
						newStr = "null"
					}
					fmt.Printf("  %s (%s): old=%s, new=%s\n", de.Path, de.Type, oldStr, newStr)
				}
			}
		}
	}
}

func fetchExistingResources(namespace string) []Resource {
	apiRes := getAPIResources()
	var all []Resource
	for _, res := range apiRes {
		args := []string{"get", res.Name, "-o", "json"}
		if res.Namespaced {
			if namespace != "" {
				args = append(args, "-n", namespace)
			} else {
				args = append(args, "--all-namespaces")
			}
		}
		cmd := exec.Command("kubectl", args...)
		out, err := cmd.Output()
		if err != nil {
			fmt.Fprintf(os.Stderr, "Warning: Failed to fetch %s: %v\n", res.Name, err)
			continue
		}
		var data struct {
			Items []Resource `json:"items"`
		}
		if err := json.Unmarshal(out, &data); err != nil {
			fmt.Fprintf(os.Stderr, "Warning: Failed to parse %s: %v\n", res.Name, err)
			continue
		}
		all = append(all, data.Items...)
	}
	return all
}

func getAPIResources() []struct {
	Name       string
	APIVersion string
	Namespaced bool
	Kind       string
} {
	cmd := exec.Command("kubectl", "api-resources", "--verbs=list", "-o", "wide")
	out, err := cmd.Output()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error getting API resources: %v\n", err)
		os.Exit(1)
	}
	lines := strings.Split(string(out), "\n")
	if len(lines) < 2 {
		return nil
	}
	header := strings.Fields(strings.ToLower(lines[0]))
	var nameIdx, apiIdx, nsIdx, kindIdx int
	for i, h := range header {
		switch h {
		case "name":
			nameIdx = i
		case "apiversion":
			apiIdx = i
		case "namespaced":
			nsIdx = i
		case "kind":
			kindIdx = i
		}
	}
	var resources []struct {
		Name       string
		APIVersion string
		Namespaced bool
		Kind       string
	}
	for _, line := range lines[1:] {
		fields := strings.Fields(line)
		if len(fields) < 4 {
			continue
		}
		namespaced := strings.ToLower(fields[nsIdx]) == "true"
		resources = append(resources, struct {
			Name       string
			APIVersion string
			Namespaced bool
			Kind       string
		}{
			Name:       fields[nameIdx],
			APIVersion: fields[apiIdx],
			Namespaced: namespaced,
			Kind:       fields[kindIdx],
		})
	}
	return resources
}

func renderHelmChart(release, chart, namespace string) []Resource {
	args := []string{"template", release, chart, "--include-crds"}
	if namespace != "" {
		args = append(args, "--namespace", namespace)
	}
	cmd := exec.Command("helm", args...)
	out, err := cmd.Output()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error rendering Helm chart: %v\n", err)
		os.Exit(1)
	}
	var docs []Resource
	dec := yaml.NewDecoder(bytes.NewReader(out))
	for {
		var doc Resource
		err := dec.Decode(&doc)
		if err == io.EOF {
			break
		}
		if err != nil {
			fmt.Fprintf(os.Stderr, "Warning: Failed to decode YAML document: %v\n", err)
			continue
		}
		if doc != nil && len(doc) > 0 {
			docs = append(docs, doc)
		}
	}
	return docs
}

func normalize(res Resource) Resource {
	cp := deepCopy(res).(Resource)
	if md, ok := cp["metadata"].(map[string]interface{}); ok {
		for _, key := range []string{"creationTimestamp", "resourceVersion", "uid", "generation", "managedFields", "selfLink"} {
			delete(md, key)
		}
	}
	delete(cp, "status")
	return cp
}

func deepCopy(val interface{}) interface{} {
	switch v := val.(type) {
	case map[string]interface{}:
		cp := make(map[string]interface{}, len(v))
		for key, value := range v {
			cp[key] = deepCopy(value)
		}
		return cp
	case []interface{}:
		cp := make([]interface{}, len(v))
		for i, value := range v {
			cp[i] = deepCopy(value)
		}
		return cp
	default:
		return v
	}
}

func compareResources(existing, rendered []Resource) []Diff {
	existingMap := make(map[[3]string]Resource)
	for _, e := range existing {
		md, ok := e["metadata"].(map[string]interface{})
		if !ok {
			continue
		}
		ns := ""
		if n, ok := md["namespace"].(string); ok {
			ns = n
		}
		name, ok := md["name"].(string)
		if !ok {
			continue
		}
		kind, ok := e["kind"].(string)
		if !ok {
			continue
		}
		key := [3]string{kind, ns, name}
		existingMap[key] = normalize(e)
	}

	var diffs []Diff
	for _, r := range rendered {
		md, ok := r["metadata"].(map[string]interface{})
		if !ok {
			continue
		}
		ns := ""
		if n, ok := md["namespace"].(string); ok {
			ns = n
		}
		name, ok := md["name"].(string)
		if !ok {
			continue
		}
		kind, ok := r["kind"].(string)
		if !ok {
			continue
		}
		key := [3]string{kind, ns, name}
		normR := normalize(r)

		var thisDiff Diff
		thisDiff.Kind = kind
		thisDiff.Namespace = ns
		thisDiff.Name = name

		exist, found := existingMap[key]
		if !found {
			thisDiff.Status = "new"
			diffs = append(diffs, thisDiff)
			continue
		}

		var diffEntries []DiffEntry
		compareValues(exist, normR, "", &diffEntries)
		if len(diffEntries) == 0 {
			continue // unchanged, skip
		}

		thisDiff.Status = "modified"
		thisDiff.Diff = diffEntries

		// Check ownership
		mdE, _ := exist["metadata"].(map[string]interface{})
		ann, _ := mdE["annotations"].(map[string]interface{})
		lab, _ := mdE["labels"].(map[string]interface{})
		isHelm := false
		if _, ok := ann["meta.helm.sh/release-name"]; ok {
			isHelm = true
		}
		if m, ok := lab["app.kubernetes.io/managed-by"]; ok {
			if strings.ToLower(fmt.Sprint(m)) == "helm" {
				isHelm = true
			}
		}
		thisDiff.Ownership = "helm"
		if !isHelm {
			thisDiff.Ownership = "other"
			thisDiff.ConflictNote = "Potential conflict: Resource exists but not managed by Helm. Deployment may overwrite it."
		}

		diffs = append(diffs, thisDiff)
	}
	return diffs
}

func compareValues(old, new interface{}, path string, diffs *[]DiffEntry) {
	switch o := old.(type) {
	case map[string]interface{}:
		n, ok := new.(map[string]interface{})
		if !ok {
			*diffs = append(*diffs, DiffEntry{Path: path, Type: "type_changed", Old: fmt.Sprintf("%T", old), New: fmt.Sprintf("%T", new)})
			return
		}
		allKeys := make(map[string]struct{})
		for k := range o {
			allKeys[k] = struct{}{}
		}
		for k := range n {
			allKeys[k] = struct{}{}
		}
		var keyList []string
		for k := range allKeys {
			keyList = append(keyList, k)
		}
		sort.Strings(keyList)
		for _, k := range keyList {
			newPath := k
			if path != "" {
				newPath = path + "." + k
			}
			ov, ohas := o[k]
			nv, nhas := n[k]
			if !ohas {
				*diffs = append(*diffs, DiffEntry{Path: newPath, Type: "added", Old: nil, New: nv})
			} else if !nhas {
				*diffs = append(*diffs, DiffEntry{Path: newPath, Type: "removed", Old: ov, New: nil})
			} else {
				compareValues(ov, nv, newPath, diffs)
			}
		}
	case []interface{}:
		n, ok := new.([]interface{})
		if !ok {
			*diffs = append(*diffs, DiffEntry{Path: path, Type: "type_changed", Old: fmt.Sprintf("%T", old), New: fmt.Sprintf("%T", new)})
			return
		}
		maxLen := len(o)
		if len(n) > maxLen {
			maxLen = len(n)
		}
		for i := 0; i < maxLen; i++ {
			newPath := fmt.Sprintf("%s[%d]", path, i)
			if i >= len(o) {
				*diffs = append(*diffs, DiffEntry{Path: newPath, Type: "added", Old: nil, New: n[i]})
			} else if i >= len(n) {
				*diffs = append(*diffs, DiffEntry{Path: newPath, Type: "removed", Old: o[i], New: nil})
			} else {
				compareValues(o[i], n[i], newPath, diffs)
			}
		}
	default:
		if old != new {
			*diffs = append(*diffs, DiffEntry{Path: path, Type: "changed", Old: old, New: new})
		}
	}
}
```

### How to Use the Tool

#### Prerequisites
- Install Go (version 1.21 or later recommended).
- Install the YAML library: `go get gopkg.in/yaml.v3`
- Ensure `kubectl` and `helm` are installed and configured to access your Kubernetes cluster.
- The tool assumes the Helm chart is local (directory or tarball).
- For advanced Helm rendering (e.g., custom values), you can modify the `renderHelmChart` function to include additional flags like `--values`, or extend the flags in `main` as needed.

#### Build and Run
1. Save the code above to a file named `main.go`.
2. Build the executable:
   ```
   go build -o helm-compare
   ```
3. Run the tool:
   ```
   ./helm-compare [flags] <chart-path>
   ```

- `<chart-path>`: Path to the Helm chart (required, e.g., `./my-chart`).
- `--release` or `-release`: Helm release name for rendering (default: `my-release`).
- `--namespace` or `-namespace`: Target namespace for namespaced resources. If omitted, fetches resources from all namespaces (for namespaced ones) and sets no namespace in Helm template.
- `--output` or `-output`: Output format (`text` for human-readable, `json` for structured output; default: `text`).

The tool functions similarly to the Python version:
- Dynamically discovers all Kubernetes resources (including CRDs and Custom Resources).
- Fetches existing resources in JSON format.
- Renders the Helm chart (including CRDs).
- Normalizes resources by removing irrelevant fields.
- Compares each rendered resource to existing ones by kind/name/namespace.
- Detects ownership via Helm-specific labels/annotations and flags potential conflicts.
- Handles cluster-wide resources separately.
- Only outputs new or modified resources (skips unchanged).
- Note: The diff ignores map order (sorts keys) but considers array order (as implementing ignore_order for arrays is complex without keys; for Kubernetes resources, order often matters or is deterministic).

#### Example
Assume a Helm chart at `./nginx-chart` deploying to namespace `web`, with an existing non-Helm-managed Deployment.

1. Run:
   ```
   ./helm-compare --release nginx-prod --namespace web ./nginx-chart
   ```

2. Sample Output (text format):
   ```
   🔍 Deployment/nginx in namespace web
   Status: modified
   Ownership: other
   ⚠️ Potential conflict: Resource exists but not managed by Helm. Deployment may overwrite it.
   Differences:
     spec.replicas (changed): old=1, new=3
   ```

   This shows differences and potential conflicts.

3. For JSON:
   ```
   ./helm-compare --release nginx-prod --namespace web --output json ./nginx-chart
   ```
   Outputs a JSON array for programmatic parsing.

#### Bonus Notes
- **CRDs and Custom Resources**: Handled automatically.
- **Diff Details**: Uses a custom recursive diff (similar to DeepDiff with ignore_order for maps but not arrays). Paths use dot notation (e.g., `spec.replicas`) for readability.
- **Extensions**: For containerization, create a Dockerfile with Go, kubectl, and Helm. To support Helm values files, add a flag and append to `helm template`.
- **Limitations**: No support for Helm hooks or post-render. Large clusters may slow fetching—consider filtering API resources if needed. Error handling is basic; enhance as required.