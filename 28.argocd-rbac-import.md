Act as an expert devops engineer to accomplish below task:

migrate/import few kubernetes clusterrole clusterrolebinding, role and rolebindimg to terraform without experincing any change in terraform plan please use import function as terraform code for importing instead of using terraform import cli



To migrate Kubernetes RBAC resources to Terraform without changes in the plan, follow these steps using Terraform's import block (available in Terraform >=1.5.0):

1. Provider Configuration

Ensure the Kubernetes provider is configured in providers.tf:

```hcl
terraform {
  required_providers {
    kubernetes = {
      source  = "hashicorp/kubernetes"
      version = "~> 2.23.0"
    }
  }
}

provider "kubernetes" {
  # Configure with your K8s cluster details
  config_path = "~/.kube/config"  # Update if needed
}
```

2. Terraform Resource Definitions

Create Terraform resource definitions matching your RBAC resources exactly. Replace placeholders (e.g., name, rules, subjects) with actual values from your cluster.

ClusterRole

```hcl
# clusterrole.tf
resource "kubernetes_cluster_role" "example" {
  metadata {
    name = "your-clusterrole-name"  # Replace with actual name
  }

  rule {
    api_groups = [""]               # Update based on kubectl describe clusterrole <name>
    resources  = ["pods"]
    verbs      = ["get", "list"]
  }
  # Add all other rules from the existing ClusterRole
}
```

ClusterRoleBinding

```hcl
# clusterrolebinding.tf
resource "kubernetes_cluster_role_binding" "example" {
  metadata {
    name = "your-clusterrolebinding-name"
  }

  subject {
    kind      = "User"
    name      = "user@example.com"  # Update with actual subject
    api_group = "rbac.authorization.k8s.io"
  }

  role_ref {
    kind      = "ClusterRole"
    name      = "target-clusterrole-name"  # Must match the ClusterRole's name
    api_group = "rbac.authorization.k8s.io"
  }
}
```

Role & RoleBinding (Namespaced)

```hcl
# role.tf
resource "kubernetes_role" "example" {
  metadata {
    name      = "your-role-name"
    namespace = "target-namespace"  # Update with the namespace
  }

  rule {
    api_groups = [""]
    resources  = ["services"]
    verbs      = ["get", "list"]
  }
}

# rolebinding.tf
resource "kubernetes_role_binding" "example" {
  metadata {
    name      = "your-rolebinding-name"
    namespace = "target-namespace"  # Must match the Role's namespace
  }

  subject {
    kind      = "ServiceAccount"
    name      = "service-account-name"  # Update with actual subject
    namespace = "service-account-namespace"
  }

  role_ref {
    kind      = "Role"
    name      = "target-role-name"  # Must match the Role's name
    api_group = "rbac.authorization.k8s.io"
  }
}
```

3. Import Blocks

Add import blocks to import existing resources into Terraform state:

```hcl
# import.tf
import {
  to = kubernetes_cluster_role.example
  id = "your-clusterrole-name"  # Name of the ClusterRole
}

import {
  to = kubernetes_cluster_role_binding.example
  id = "your-clusterrolebinding-name"  # Name of the ClusterRoleBinding
}

import {
  to = kubernetes_role.example
  id = "target-namespace/your-role-name"  # Format: namespace/name
}

import {
  to = kubernetes_role_binding.example
  id = "target-namespace/your-rolebinding-name"  # Format: namespace/name
}
```

4. Execute Import

Run the following commands:

```bash
terraform init
terraform plan -generate-config-out=generated.tf  # Generates config for any missing resources
terraform apply  # Will import resources and show no changes if definitions match
```

Key Notes:

· Exact Matching: Ensure Terraform resource arguments (e.g., rules, subjects, role_ref) exactly match the live Kubernetes resources. Use kubectl get clusterrole <name> -o yaml to verify.
· Namespace Awareness: Roles and RoleBindings require explicit namespace fields.
· Post-Import Cleanup: After successful import, remove the import blocks to avoid conflicts in future runs.

This approach ensures Terraform adopts existing resources without altering their state. If the plan shows changes, adjust your Terraform configuration to match the live resource exactly.