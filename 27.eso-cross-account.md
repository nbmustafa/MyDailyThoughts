```
act as an expert Devops Engineer to accomolish below task: 
as a kubernetes platform engineer i want you to configure below scenario in terraform:

· we have one management aws accoumt called mgmt has all secrets stored there
· we create eks cluster for our customer in thier aws account. and part of cluster creation we have External Secrets Operator (eso) on tenant cluster in tenant aws account to pull secrets from mgmt account and create k8s secret. how do we design,and configure the IAM roles and policies, as well as eso service account to allow eso from tenant account to pull secreta from managememt account.

please note: we need a scalable solution as our tenants are growing and we may jave more than 200 tenants. we want secure solution but also scalable and less operatiom oberhead
```

Nice — I’ll act as your DevOps/Kubernetes platform engineer and give you a secure, scalable, production-ready design plus concrete Terraform examples you can drop into your tenant onboarding automation. I’ll show two workable approaches (one I recommend) and provide Terraform snippets for the Management account (where secrets live) and for each Tenant account / EKS cluster (where ESO runs). I’ll also include the ExternalSecrets Operator (ESO) config that ties it together and operational notes for scaling to 200+ tenants.


---

Summary (short)

Recommended approach: Use IRSA in each tenant account (a Kubernetes ServiceAccount → IAM Role in tenant), let that tenant-role have sts:AssumeRole permission for a management-account role (read-only secrets role). Tenant pods use IRSA to get temporary creds, then AssumeRole into the management role to read Secrets Manager/SSM secrets. This keeps secrets in mgmt account, enforces least privilege, and is automatable per-tenant.

Alternative: Use Secrets Manager resource policies that allow cross-account access directly from tenant principals (works, but resource policies per-secret can be harder to manage at scale).

Provide Terraform modules: one for mgmt (create mgmt role + policy), one for tenant (create IRSA role bound to SA, and policy allowing assumeRole). Onboarding script creates a tenant IRSA role and adds tenant principal into mgmt role trust or uses Org-level trust to avoid creating 200 mgmt roles.

ESO config: run ESO in tenant cluster using the IRSA service account; ESO will use the IRSA role to call STS:AssumeRole into mgmt role and then call SecretsManager:GetSecretValue.

---

Design choices & rationale

Requirements mapping

Secrets are stored in mgmt AWS account.
Tenants run EKS clusters in their own AWS accounts.
ESO runs in tenant cluster and must read secrets from mgmt account and create Kubernetes Secrets in the tenant cluster.
Need secure, least-privilege, and scalable (200+ tenants) solution with low ops overhead.

Why I recommend IRSA + cross-account AssumeRole

IRSA (IAM Roles for Service Accounts) gives fine-grained pod-level credentials without node IAM keys.
Tenant IRSA role is created in tenant account and bound to the ESO ServiceAccount (via OIDC).
Tenant IRSA role has a tiny permission set (only sts:AssumeRole to the mgmt role).

Mgmt account exposes a single "read-secrets" role that allows secretsmanager:GetSecretValue (and List if needed) and trusts tenants to assume it. The trust policy can be controlled to restrict to:
specific tenant role ARNs (most secure), or every account in the Organization with a condition (aws:PrincipalOrgID), or a list of allowed tenant account IDs (semi-automated).
This approach centralizes secret permissions in mgmt account and keeps tenant-side permissions minimal. It is easy to automate: tenant onboarding Terraform creates the IRSA role and registers the tenant principal with mgmt role trust, or uses Org-level trust to avoid touching mgmt for every tenant.

Alternative: Secrets Manager resource policies
Instead of AssumeRole, attach a resource-based policy on each secret (or a secret prefix) that allows principals in tenant accounts to access it.
Pros: fewer role assumptions.
Cons: managing per-secret policies at scale can be heavy. Harder to maintain one-off per-tenant exceptions. Less standard for k8s setups that expect an assume-role flow.


---
Security controls (recommended)

- Least privilege: mgmt role only secretsmanager:GetSecretValue (and maybe DescribeSecret, ListSecretVersionIds) limited to specific secret ARNs or a path pattern.
- Trust conditions: Use aws:PrincipalOrgID or exact principal ARNs in mgmt role trust. Use aws:SourceIp/MFA not applicable here.
- Auditing: CloudTrail + AWS Config for cross-account assumeRole and SecretsManager access.
- Rotation/automation: automate secret creation and tagging in mgmt; use tags to grant/deny actions.
- Network: SecretsManager API calls are over TLS — no need for cross-account VPC peering — ESO will call the AWS APIs from tenant pods.

---

Terraform implementation (concept + copy/paste-ready snippets)
I’ll provide two sets of Terraform code: Management account and Tenant account. Wrap these into modules for onboarding.

> Notes:
Replace var.<...> placeholders with your values (account IDs, ARNs, cluster OIDC issuer URL).
These are minimal examples; you’ll extend them (extra policies, logging, tags) to match your requirements.
I’ll show the AssumeRole-based flow (recommended).

---

1) Management account Terraform
Create a role mgmt-secrets-reader that can be assumed by tenant principals and has permission to read specific secrets.

# management/main.tf

```hcl
variable "mgmt_account_id" {}
variable "allowed_tenant_principals" {
  type = list(string)
  # e.g. ["arn:aws:iam::111111111111:role/tenant-eso-irsa-role", ...] - either explicit list or generated during onboarding
}

# Policy granting read-only SecretsManager access (scope to ARNs if possible)
resource "aws_iam_policy" "mgmt_read_secrets_policy" {
  name        = "mgmt-secrets-reader-policy"
  description = "Policy to read secrets from Secrets Manager (for External Secrets Operator)"
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Sid = "SecretsGet"
        Effect = "Allow"
        Action = [
          "secretsmanager:GetSecretValue",
          "secretsmanager:DescribeSecret",
          "secretsmanager:ListSecretVersionIds"
        ]
        Resource = [
          # narrow this to exact secret ARNs if possible. Example wildcard across a prefix:
          "arn:aws:secretsmanager:${data.aws_region.current.name}:${var.mgmt_account_id}:secret:myapp/*"
        ]
      }
    ]
  })
}

# mgmt role that tenant principals can assume
resource "aws_iam_role" "mgmt_secrets_reader_role" {
  name = "mgmt-secrets-reader-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Principal = {
          AWS = var.allowed_tenant_principals
        }
        Action = "sts:AssumeRole"
        # No ExternalId here — if you want extra defense, on the tenant side you can pass an external id and check it in a condition.
      }
    ]
  })
}

resource "aws_iam_role_policy_attachment" "attach_mgmt_policy" {
  role       = aws_iam_role.mgmt_secrets_reader_role.name
  policy_arn = aws_iam_policy.mgmt_read_secrets_policy.arn
}

```

Scalability options for allowed_tenant_principals

**Most secure**: add each tenant IRSA role ARN to allowed_tenant_principals during onboarding (Terraform apply in mgmt account).
**Less operational overhead**: replace the Principal with the tenant AWS Organization condition allowing any role from accounts in your AWS Org:

```hcl
# alternative trust policy fragment using AWS Organization
assume_role_policy = jsonencode({
  Version = "2012-10-17"
  Statement = [
    {
      Effect = "Allow"
      Principal = { AWS = "*" }  # principal left broad
      Action = "sts:AssumeRole"
      Condition = {
        StringEquals = {
          "aws:PrincipalOrgID" = "o-xxxxxxxxxx"   # your Org ID
        }
      }
    }
  ]
})

```

When using Org-based trust, further restrict by requiring the principal ARN contain a known prefix or by tagging principals and using aws:PrincipalTag conditions.

---

2) Tenant account Terraform For each tenant EKS cluster, create:

  1. OIDC provider (if EKS cluster not already configured)
  2. IRSA role bound to the ESO ServiceAccount
  3. Policy allowing sts:AssumeRole to management role.

This role will be attached to the ServiceAccount via annotation (IRSA).

# tenant/main.tf

```hcl
variable "tenant_account_id" {}
variable "eks_cluster_name" {}
variable "eks_oidc_issuer" {}      # e.g. data from aws_eks_cluster.identity[0].oidc[0].issuer
variable "namespace" { default = "external-secrets" }
variable "service_account_name" { default = "external-secrets-operator" }
variable "mgmt_role_arn" {}        # ARN of aws_iam_role.mgmt_secrets_reader_role in mgmt account
variable "external_id" { default = null } # optional extra secret

# 1) Ensure OIDC provider exists for your cluster (skip if it's created via eks module)
resource "aws_iam_openid_connect_provider" "oidc" {
  client_id_list  = ["sts.amazonaws.com"]
  thumbprint_list = [/* the cluster thumbprint, or use data source */]
  url             = replace(var.eks_oidc_issuer, "https://", "")
  # If provider already exists, use data.aws_iam_openid_connect_provider instead.
}

# 2) Create IRSA role (assume via web identity)
data "aws_iam_policy_document" "irsa_assume_role_policy" {
  statement {
    effect = "Allow"
    principals {
      type        = "Federated"
      identifiers = [aws_iam_openid_connect_provider.oidc.arn]
    }
    actions = ["sts:AssumeRoleWithWebIdentity"]

    condition {
      test     = "StringEquals"
      variable = "${replace(var.eks_oidc_issuer, "https://", "")}:sub"
      values   = ["system:serviceaccount:${var.namespace}:${var.service_account_name}"]
    }
  }
}

resource "aws_iam_role" "tenant_irsa_role" {
  name               = "tenant-${var.eks_cluster_name}-eso-irsa-role"
  assume_role_policy = data.aws_iam_policy_document.irsa_assume_role_policy.json
  tags = {
    created_by = "eso_irsa_module"
    tenant     = var.tenant_account_id
  }
}

# 3) Allow this tenant role to call sts:AssumeRole on mgmt role
data "aws_iam_policy_document" "allow_assume_mgmt_role" {
  statement {
    effect = "Allow"
    actions = ["sts:AssumeRole"]
    resources = [var.mgmt_role_arn]
  }
}

resource "aws_iam_policy" "tenant_assume_policy" {
  name   = "tenant-${var.eks_cluster_name}-assume-mgmt-role"
  policy = data.aws_iam_policy_document.allow_assume_mgmt_role.json
}

resource "aws_iam_role_policy_attachment" "attach_assume_policy" {
  role       = aws_iam_role.tenant_irsa_role.name
  policy_arn = aws_iam_policy.tenant_assume_policy.arn
}
```

Kubernetes ServiceAccount with annotation (bind role to SA)
You can create the K8s ServiceAccount with the annotation eks.amazonaws.com/role-arn so pods using it will receive IRSA credentials:

```hcl
provider "kubernetes" {
  host                   = data.aws_eks_cluster.cluster.endpoint
  cluster_ca_certificate = base64decode(data.aws_eks_cluster.cluster.certificate_authority[0].data)
  token                  = data.aws_eks_cluster_auth.cluster.token
}

resource "kubernetes_service_account" "eso_sa" {
  metadata {
    name      = var.service_account_name
    namespace = var.namespace
    annotations = {
      "eks.amazonaws.com/role-arn" = aws_iam_role.tenant_irsa_role.arn
    }
  }
}
```
Important: If you annotate the SA, the pod will automatically get temporary creds via AWS SDK using the web-identity token.

---

3) External Secrets Operator configuration (in tenant cluster)
   
ESO needs to assume the mgmt role (the role in the management account) using the tenant IRSA role's temporary creds. The ESO AWS provider configuration can be done either globally (operator config) or per ExternalSecret provider. Two important points:

The tenant IRSA role must have sts:AssumeRole permission for the management role ARN (we gave it above).

In the ESO provider config you set roleArn pointing to arn:aws:iam::<mgmt_account_id>:role/mgmt-secrets-reader-role. ESO will call STS:AssumeRole and use the returned creds to call Secrets Manager.

Example ExternalSecret provider snippet (ESO v0.x CRD style varies by version — adjust to your ESO version; this is a common pattern):

# example: external-secret-provider config maps to 
```yaml
SecretStore or ClusterSecretStore
apiVersion: external-secrets.io/v1beta1
kind: ClusterSecretStore
metadata:
  name: aws-mgmt-store
spec:
  provider:
    aws:
      service: SecretsManager
      region: us-east-1
      # role to assume in mgmt account
      role: arn:aws:iam::123456789012:role/mgmt-secrets-reader-role
      # optionally: externalID: "tenant-123"   # if you use external_id patterns
```

Then an ExternalSecret that pulls a secret:
```yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: my-db-credentials
  namespace: default
spec:
  refreshInterval: "1h"
  secretStoreRef:
    name: aws-mgmt-store
    kind: ClusterSecretStore
  target:
    name: my-db-secret
  data:
    - secretKey: username
      remoteRef:
        key: prod/db/my-service/username
    - secretKey: password
      remoteRef:
        key: prod/db/my-service/password
```

How ESO authenticates at runtime:

1. Pod using external-secrets-operator serviceAccount gets IRSA temporary creds (web identity → tenant IRSA role).
2. ESO (running with AWS SDK) invokes sts:AssumeRole into mgmt role (spec.role) — the tenant IRSA role is allowed to do so.
3. After assuming the mgmt role, ESO calls SecretsManager and fetches secrets, then writes k8s secrets in the tenant cluster.

---

Alternative: Secrets Manager resource-based policy
If you want to avoid AssumeRole complexity, you can attach a resource policy to a secret allowing principals from tenant accounts/roles:
```hcl
resource "aws_secretsmanager_secret_policy" 
"example_secret_policy" {
  secret_arn = aws_secretsmanager_secret.example.arn
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Sid = "AllowTenantAccess"
        Effect = "Allow"
        Principal = {
          AWS = [
            "arn:aws:iam::111111111111:role/tenant-eso-irsa-role",
            "arn:aws:iam::222222222222:role/tenant-eso-irsa-role"
          ]
        }
        Action = [
          "secretsmanager:GetSecretValue",
          "secretsmanager:DescribeSecret"
        ]
        Resource = "*"
      }
    ]
  })
}
```
This method can be simpler in small setups but becomes cumbersome at scale (many secrets or many tenants).
It also leaves less unified central control compared to a single mgmt role.

---

Tenant onboarding pattern (automation)
Create a small onboarding pipeline (Terraform module + CI/CD) that:

1. Runs Terraform in tenant account to create IRSA role and attach sts:AssumeRole permission to mgmt role.
2. Optionally updates mgmt account trust (add tenant principal to allowed_tenant_principals) OR use Org-based trust in mgmt role so step (2) not required.
3. Deploys ESO and the ServiceAccount (or bind via annotation).
4. Creates ClusterSecretStore in the tenant cluster pointing to mgmt role ARN.
5. Creates ExternalSecret objects to map mgmt secrets into k8s.

If you want zero-touch mgmt-side changes: use the Org-based trust pattern for mgmt_secrets_reader_role. That way tenant onboarding only touches tenant account and k8s cluster.

---
Operational notes & recommendations

Prefer one mgmt role + Org trust if tenants are in same AWS Organization; this reduces management overhead (no per-tenant creation in mgmt). Add extra conditions (principal tags, required sub) if you want more strictness.

If tenants are not in the same Org, create per-tenant principal entries in mgmt role trust or create per-tenant mgmt roles via automation.

Use resource-ARN scoping for secrets in mgmt policy — avoid wildcard *.

Monitor: enable CloudTrail in mgmt account for STS and SecretsManager events; send alerts on unexpected reads.

Limit ESO scope: deploy ESO with RBAC limited to the namespace where it must create secrets.

Rotate mgmt secrets and manage versions; ESO will pick latest if requested.

Tagging: tag roles and secrets per tenant to make auditing easy.

Least privilege: tenant IRSA role should only get sts:AssumeRole on mgmt role — nothing else.

---

Recommended Terraform module structure
modules/mgmt-secrets-role/ — creates mgmt role + read policy + optional trust updates
modules/tenant-irsa/ — creates OIDC provider (if needed), IRSA role, policy to assume mgmt role, k8s SA
modules/tenant-eso-deploy/ — deploys ESO helm chart and ClusterSecretStore cluster resources (can be done via flux/argo/terraform provider)

---

Concrete checklist for implementation

1. In mgmt account: create mgmt-secrets-reader-role (or a per-tenant role) with SecretsManager read permissions.
2. Configure trust: either add tenant principal ARNs or allow your Org via aws:PrincipalOrgID condition.
3. In tenant account: ensure EKS cluster has OIDC provider or create it, create IRSA role bound to ESO serviceaccount (via sub condition).
4. Give tenant IRSA role permission to sts:AssumeRole for mgmt role ARN.
5. Deploy ESO in tenant cluster using the annotated serviceaccount.
6. Create ClusterSecretStore / SecretStore in cluster referencing role (mgmt role ARN).
7. Create ExternalSecret resources mapping remote secrets to k8s secrets.
8. Test with single tenant, verify CloudTrail logs show AssumeRole and GetSecretValue from mgmt account.

---

Example end-to-end flow (runtime)

Pod runs ESO using service account external-secrets-operator → Linux file /var/run/secrets/eks.amazonaws.com/serviceaccount/token.
SDK uses that token to get temporary creds (IRSA tenant role).
ESO calls sts:AssumeRole to arn:aws:iam::<mgmt_account>:role/mgmt-secrets-reader-role.
STS returns temporary credentials scoped to mgmt secrets read permission.
ESO calls secretsmanager:GetSecretValue(arn:...) and writes the k8s Secret in tenant cluster's namespace.

---

Final recommendations & next steps I can do for you

1. I recommend IRSA + single mgmt role with Org-based trust (if tenants are in same AWS Org). This is the best tradeoff between security and low operational overhead.
2. If you want, I can:
produce a ready-to-run Terraform module for mgmt and tenant (with variables and outputs), or
produce a turnkey onboarding script (Terraform + CI pipeline snippets) to onboard a new tenant automatically,
produce the exact ClusterSecretStore and ExternalSecret YAMLs tailored to your ESO version

Tell me which of the above you want me to generate next (the Terraform modules for mgmt, for tenant, or both + onboarding automation), and I’ll output complete Terraform module code and usage examples you can paste into your pipeline.

