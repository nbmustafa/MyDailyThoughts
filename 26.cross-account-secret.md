act as an expert Devops Engineer to accomolish below task:

1. as a kubernwtes platform engineer i need your help to configure below scenario in terraform:

· we have one management aws accoumt called mgmt has all secrets stored there
· we create eks cluster for our customer in thier aws account. and part of cluster creation we have External Secrets Operator (eso) on tenant cluster in tenant aws account to pull secrets from mgmt account and create k8s secret. how do we design,and configure the IAM roles and policies, as well as eso service account to allow eso from tenant account to pull secreta from managememt account.

please note: we need a scalable solution as our tenants are growing and we may jave more than 200 tenants. we want secure solution but also scalable and less operatiom oberhead


Of course. As a seasoned DevOps/Kubernetes platform engineer, I'll outline a robust, scalable, and secure design for this multi-account secret synchronization setup using Terraform.

Core Design Philosophy

We will use the AWS STS AssumeRole mechanism. This is the most scalable and secure method for cross-account access. The ESO pod in the tenant cluster will assume a specific IAM Role in the management (mgmt) account to gain temporary credentials to read secrets from AWS Secrets Manager or Parameter Store.

This design is scalable because adding a new tenant only requires creating a new trust relationship entry in the mgmt account's role, which can be highly automated.

---

Architecture Overview

1. Mgmt Account (mgmt):
   · Holds the secrets in AWS Secrets Manager.
   · Contains an IAM Role (ESO-CrossAccount-Access-Role) that grants read access to these secrets.
   · This role's trust policy allows specific IAM Roles from tenant accounts to assume it.
2. Tenant Account (tenant-x):
   · Hosts the EKS cluster.
   · Contains an IAM Role for Kubernetes Service Accounts (IRSA) attached to the ESO service account.
   · The ESO pod uses this service account to authenticate with AWS IAM.
   · ESO configuration is told to assume the role in the mgmt account.

---

Step-by-Step Terraform Configuration

We'll structure our Terraform code into at least two parts: one module (or set of resources) for the mgmt account and one for the tenant account. The mgmt account configuration can be applied once, and the tenant account configuration is applied per tenant.

Part 1: Management Account (mgmt) Configuration

This Terraform is applied in the mgmt AWS account.

mgmt_account/main.tf

```hcl
# Variables (to be supplied, e.g., from terraform.tfvars)
variable "tenant_aws_account_ids" {
  description = "List of AWS Account IDs for all tenants that need secret access"
  type        = list(string)
  default     = [] # This can be populated dynamically as you onboard tenants
}

# 1. IAM Role in Mgmt Account that Tenant ESO will assume
resource "aws_iam_role" "eso_cross_account_role" {
  name               = "ESO-CrossAccount-Access-Role"
  description        = "Grants ESO from tenant accounts read access to secrets"
  assume_role_policy = data.aws_iam_policy_document.assume_role_policy.json
}

# 2. Trust Policy: Who can assume this role?
data "aws_iam_policy_document" "assume_role_policy" {
  statement {
    effect  = "Allow"
    actions = ["sts:AssumeRole"]

    principals {
      type        = "AWS"
      identifiers = var.tenant_aws_account_ids
      # For scalability, we use the tenant account ID as the principal.
      # The exact IAM Role in the tenant account will be restricted in the Condition.
    }

    condition {
      test     = "StringEquals"
      variable = "sts:ExternalId"
      values   = [for account_id in var.tenant_aws_account_ids : "eso-tenant-${account_id}"]
      # ExternalId adds a critical security layer, ensuring the request
      # is coming from your intended tenant role. This should be unique per tenant.
    }
  }
}

# 3. Policy granting read access to secrets
resource "aws_iam_policy" "secret_read_access" {
  name        = "ESO-Secrets-ReadOnly"
  description = "Read-only access to secrets for ESO"
  policy      = data.aws_iam_policy_document.secret_read_access.json
}

data "aws_iam_policy_document" "secret_read_access" {
  # Grant permissions to Secrets Manager
  statement {
    effect = "Allow"
    actions = [
      "secretsmanager:GetResourcePolicy",
      "secretsmanager:GetSecretValue",
      "secretsmanager:DescribeSecret",
      "secretsmanager:ListSecrets"
    ]
    resources = ["*"] # For least privilege, replace with a list of specific secret ARNs
  }

  # Optional: Grant permissions to SSM Parameter Store
  statement {
    effect = "Allow"
    actions = [
      "ssm:GetParameter",
      "ssm:GetParameters"
    ]
    resources = ["*"] # For least privilege, replace with a list of specific parameter ARNs
  }
}

# 4. Attach the policy to the role
resource "aws_iam_role_policy_attachment" "eso_secret_access" {
  role       = aws_iam_role.eso_cross_account_role.name
  policy_arn = aws_iam_policy.secret_read_access.arn
}

# Outputs to be used by Tenant Account configuration
output "cross_account_role_arn" {
  description = "ARN of the IAM role in the mgmt account to be assumed by ESO"
  value       = aws_iam_role.eso_cross_account_role.arn
}
```

Part 2: Tenant Account Configuration

This Terraform is applied in each tenant's AWS account.

tenant_account/main.tf

```hcl
# Variables
variable "mgmt_aws_account_id" {
  description = "The AWS Account ID of the management account"
  type        = string
}

variable "cluster_name" {
  description = "The name of the EKS cluster"
  type        = string
}

variable "eso_namespace" {
  description = "The namespace where ESO will be installed"
  type        = string
  default     = "external-secrets"
}

# 1. Create an OIDC provider for the EKS cluster (if it doesn't exist)
data "tls_certificate" "cluster" {
  url = aws_eks_cluster.this.identity[0].oidc[0].issuer
}

resource "aws_iam_openid_connect_provider" "cluster" {
  client_id_list  = ["sts.amazonaws.com"]
  thumbprint_list = [data.tls_certificate.cluster.certificates[0].sha1_fingerprint]
  url             = aws_eks_cluster.this.identity[0].oidc[0].issuer
}

# 2. IAM Role for the ESO Service Account (IRSA)
resource "aws_iam_role" "eso_tenant_role" {
  name = "${var.cluster_name}-eso-tenant-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Principal = {
          Federated = aws_iam_openid_connect_provider.cluster.arn
        }
        Action = "sts:AssumeRoleWithWebIdentity"
        Condition = {
          StringEquals = {
            # This binds the role to the specific Kubernetes Service Account
            "${replace(aws_iam_openid_connect_provider.cluster.url, "https://", "")}:sub" : "system:serviceaccount:${var.eso_namespace}:external-secrets"
          }
        }
      }
    ]
  })
}

# 3. Policy that allows assuming the role in the mgmt account
resource "aws_iam_policy" "assume_mgmt_role" {
  name        = "AssumeMgmtESORole"
  description = "Allows assuming the ESO role in the mgmt account"

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect   = "Allow"
        Action   = "sts:AssumeRole"
        Resource = "arn:aws:iam::${var.mgmt_aws_account_id}:role/ESO-CrossAccount-Access-Role"
        Condition = {
          StringEquals = {
            "sts:ExternalId" = "eso-tenant-${data.aws_caller_identity.current.account_id}"
          }
        }
      }
    ]
  })
}

data "aws_caller_identity" "current" {} # Gets current tenant account ID

# 4. Attach the assume role policy to the tenant IAM role
resource "aws_iam_role_policy_attachment" "tenant_assume_role" {
  role       = aws_iam_role.eso_tenant_role.name
  policy_arn = aws_iam_policy.assume_mgmt_role.arn
}

# 5. Annotate the ESO Kubernetes Service Account with the IAM role ARN
# This is done via the Helm chart values or a separate kubernetes_manifest resource.
# The easiest way is to let the Helm chart for ESO handle it by setting `serviceAccount.annotations`.
```

tenant_account/eso-helm-values.yaml

```yaml
serviceAccount:
  create: true
  name: "external-secrets"
  annotations:
    # This critical annotation tells the EKS node to use the IAM role we created.
    eks.amazonaws.com/role-arn: arn:aws:iam::<TENANT_ACCOUNT_ID>:role/<CLUSTER_NAME>-eso-tenant-role

# The ESO SecretStore CRD points to the mgmt role
secretStore:
  defaults:
    assumeRole: "arn:aws:iam::<MGMT_ACCOUNT_ID>:role/ESO-CrossAccount-Access-Role"
    # External ID is a required field for assuming a role in another account
    externalID: "eso-tenant-<TENANT_ACCOUNT_ID>"
```

---

How It All Works Together

1. Pod Identity: The ESO pod has a service account annotated with the tenant IAM role ARN (aws_iam_role.eso_tenant_role.arn).
2. Token Injection: EKS injects temporary credentials for this tenant IAM role into the pod.
3. Assume Role Call: ESO uses its injected credentials to call sts:AssumeRole, requesting to assume the mgmt account role (ESO-CrossAccount-Access-Role). It must provide the correct ExternalId (eso-tenant-<TENANT_ACCOUNT_ID>) to be authorized.
4. Temporary Mgmt Credentials: AWS STS returns temporary credentials for the mgmt account role.
5. Fetch Secrets: ESO uses these new temporary credentials to call secretsmanager:GetSecretValue in the mgmt account and retrieve the secret values.
6. Create K8s Secret: ESO creates a corresponding Kubernetes Secret in the tenant cluster.

---

Scalability and Operational Overhead

· Scalable: To onboard Tenant 201, you simply:
  1. Add their AWS Account ID to the tenant_aws_account_ids list in the mgmt account Terraform and apply.
  2. Run the standard, reusable tenant account Terraform in the new tenant's account. This is perfect for a GitOps pipeline.
· Secure:
  · Uses IAM Roles and temporary credentials, no long-lived access keys.
  · Uses sts:ExternalId to prevent "confused deputy" problems.
  · Access is scoped to the minimal required permissions (read-only).
· Low Overhead: The entire process for a new tenant is adding one value to a list and running a standardized Terraform module. There is no need to create new roles or policies in the mgmt account for each tenant.

Final Recommendation

1. Use Terraform Workspaces or a CI/CD Pipeline to manage the state for the numerous tenant accounts effectively.
2. Enforce Least Privilege: Instead of resources = ["*"] in the mgmt policy, design a naming convention for secrets (e.g., tenant-<id>/<secret-name>) and restrict the policy to "arn:aws:secretsmanager:region:mgmt-account-id:secret:tenant-${aws:PrincipalAccount}/*" using IAM policy variables. This would automatically allow a tenant to only read secrets prefixed with their own account ID.
3. Consider a GitOps Flow: Have developers submit a Merge Request to add their account ID to the mgmt list. Automated CI/CD pipelines then apply the Terraform changes, reducing the operational load on your platform team.

This design provides a enterprise-grade, secure, and highly scalable foundation for your multi-tenant secret management strategy.